<!DOCTYPE html>
<html>
    <head>
        <title>nl</title>
        <meta charset="utf-8">
        <link href="style.css" rel="stylesheet">
    </head>
    <body>
        <div>
            <div id="linearea"></div>
            <pre class="codearea" id="codearea" contenteditable="true" spellcheck="false" autocomplete="off"><br></pre>
            <div class="codearea" id="highlight" spellcheck="false"></div>
        </div>
    </body>
</html>
<script>


function tokenaize(c) {
        let p = 0;
        let searchtype = [
            ["RETURN","return"],
            ["IF","if"],
            ["ELSE","else"],
            ["BOOL","true"],
            ["BOOL","false"],
            ["CONST","const"],
            ["FOR","for"],
            ["LET","let"],
            ["VAR","var"],
            ["NEW","new"],
            ["EQUAL","=="],
            ["NOTEQUAL","!="],
            ["ASSIGN","="],
            ["PLUS","+"],
            ["MINUS","-"],
            ["MUL","*"],
            ["NOT","!"],
            ["DIV","/"],
            ["LESS","<"],
            ["GREATER",">"],
            ["LPAREN","("],
            ["RPAREN",")"],
            ["LBRACE","{"],
            ["RBRACE","}"],
            ["LBRACKET","["],
            ["RBRACKET","]"],
            ["SEMICOLON",";"],
            ["COLON",":"],
        ]
        let token = []
        while (p<c.length) {
            console.log(c.slice(p,8))
            if (c[p]=="f"&&c[p+1]=="u"&&c[p+2]=="n"&&c[p+3]=="c"&&c[p+4]=="t"&&c[p+5]=="i"&&c[p+6]=="o"&&c[p+7]=="n"&&c[p+8]==" ") {
                token.push(["FUNCTION","function"]);
                token.push(["BLANK"," "])
                p+=9
                let scomment = p
                while (!(c[p]=="("||c[p]==")"||c[p]==" ")) {
                    p++;
                }
                token.push(["FUNCTIONNAME",c.slice(scomment,p)])
                continue;
            }
            if (c[p]==" ") {
                let scomment = p
                while (c[p]==" ") {
                    p++;
                }
                token.push(["BLANK",c.slice(scomment,p)])
                continue;
            }
            else if (c[p]=="\n") {
                p+=1;
                token.push(["CR","\n"])
                continue;
            }
            else if (c[p]=="/"&&c[p+1]=="*") {
                let scomment = p
                p+=2;
                while (!((c[p]=="*"&&c[p+1]=="/")||c[p+1]==null)) {
                    if (c[p]==" ") {
                        token.push(["BCOMMENT",c.slice(scomment,p)])
                        scomment = p
                        while (c[p]==" ") {
                            p++;
                        }
                        token.push(["BLANK",c.slice(scomment,p)])
                        scomment = p
                        continue;
                    }
                    else if (c[p]=="\n") {
                        token.push(["BCOMMENT",c.slice(scomment,p)])
                        token.push(["CR","\n"])
                        p++;
                        scomment = p
                        continue;
                    }
                    p++
                }
                if (c[p+1]==null) {
                    p+=2;
                    token.push(["BCOMMENT",c.slice(scomment,p)])
                    token.push(["CR","\n"])
                }
                else {
                    p+=2;
                    token.push(["BCOMMENT",c.slice(scomment,p)])
                }
                continue;
            }
            else if (c[p]=="/"&&c[p+1]=="/") {
                let scomment = p
                while (!(c[p+1]=="\n"||c[p+1]==null)) {
                    if (c[p]==" ") {
                        token.push(["LCOMMENT",c.slice(scomment,p)])
                        scomment = p
                        while (c[p]==" ") {
                            p++;
                        }
                        token.push(["BLANK",c.slice(scomment,p)])
                        scomment = p
                        continue;
                    }
                    p++;
                }
                p+=1;
                token.push(["LCOMMENT",c.slice(scomment,p)])
                continue;
            }
            else if (c[p]=='"') {
                let scomment = p
                    p++;
                while ((c[p]!='"')) {
                    if (c[p]==null||c[p]=="\n") { break; }
                    p++;
                }
                p++;
                token.push(["STRING",c.slice(scomment,p)])
            }
            else if (c[p]=="'") {
                let scomment = p
                    p++;
                while ((c[p]!="'")) {
                    if (c[p]==null||c[p]=="\n") { break; }
                    p++;
                }
                p++;
                token.push(["STRING",c.slice(scomment,p)])
            }
            else if (c[p]=="`") {
                let scomment = p
                    p++;
                while ((c[p]!="`")) {
                    if (c[p]==null) { break; }
                    if (c[p]=="\n") {
                        token.push(["STRING",c.slice(scomment,p)])
                        token.push(["CR","\n"])
                        p++;
                        scomment = p
                        continue;
                    }
                    p++;
                }
                p++;
                token.push(["STRING",c.slice(scomment,p)])
            }

            token.push(["VARIABLE",""]);
            if (!(c[p]==" "||c[p]=="\n"||c[p]==null)) {
                let opflag = false;
                let mlcomm = false;
                for (let o=0;o<searchtype.length;o++) {
                    if (c.startsWith(searchtype[o][1],p)) {
                        p+=searchtype[o][1].length;
                        if (token[token.length-1][1]!="") {
                            token[token.length]=searchtype[o];
                        }
                        else {
                            token[token.length-1]=searchtype[o];
                        }
                        if (token[token.length-1][0]=="COLON"&&token[token.length-2][0]=="VARIABLE") {
                            token[token.length-2][0]="TYPE";
                        }
                        token.push(["VARIABLE",""]);
                        opflag = true;
                        break;
                    }
                }
                if (!opflag) {
                    token[token.length-1][1]+=c[p];
                    if (token[token.length-1][0]=="VARIABLE") {
                        let nums = [0,1,2,3,4,5,6,7,8,9];
                        for (let n=0;n<nums.length;n++) {
                            if (token[token.length-1][1][0]==nums[n]) {
                                token[token.length-1][0]="DIGITS"
                            }
                        }
                    }
                    p++;
                }
            }
            if (token[token.length-1][1]=="") {
                token.splice(token.length-1,1);
            }
        }
        let brcnt = 0
        token.push(["EOF",""])
        return token;
    }
function highlight() {
    tokens = tokenaize(codeelm.innerText)
    outelm.innerHTML = "";
    linearea.innerHTML = "";
        let brcnt = 0
        let pacnt = 0
        let bracnt = 0
        let linecnt = 1
    for (let t=0;t<tokens.length;t++) {
        if (tokens[t][0]=="CR") {
            linecnt++
        }
        thistoken = document.createElement("pre")
        thistoken.innerHTML += tokens[t][1]
        thistoken.className = tokens[t][0]
        let ccnt = ""
        {
            if (tokens[t][0].slice(1)=="BRACE") {
                if (tokens[t][0][0]=="L") {
                    brcnt++
                    ccnt = brcnt.toString();
                }
                else {
                    ccnt = brcnt.toString();
                    brcnt--
                }
                thistoken.className += " "+ccnt
            }
            if (tokens[t][0].slice(1)=="PAREN") {
                if (tokens[t][0][0]=="L") {
                    pacnt++
                    ccnt = pacnt.toString();
                }
                else {
                    ccnt = pacnt.toString();
                    pacnt--
                }
                thistoken.className += " "+ccnt
            }
            if (tokens[t][0].slice(1)=="BRACKET") {
                if (tokens[t][0][0]=="L") {
                    bracnt++
                    ccnt = bracnt.toString();
                }
                else {
                    ccnt = bracnt.toString();
                    bracnt--
                }
                thistoken.className += " "+ccnt
            }
        }
        outelm.append(thistoken)
    }
    for (let l=1;l<linecnt;l++) {
        lintken = document.createElement("pre")
        lintken.innerHTML = l.toString()+"\n"
        linearea.appendChild(lintken)
    }
}
outelm = document.getElementById("highlight")
codeelm = document.getElementById("codearea")
linearea = document.getElementById("linearea")
codeelm.onkeyup = highlight
codeelm.onkeydown = highlight

codeelm.addEventListener("paste", function(e) { // 参考: https://qiita.com/tashinoso/items/5519a5fa56e7585d8a93
    e.preventDefault();
    var text = e.clipboardData.getData("text/plain")+"<br>";
    document.execCommand("insertHTML", false, text);
});

highlight()

</script>
<style>
    * {
        font-family: monospace;
    }
    pre.codearea {
        display: block;
    }
    pre {
        margin: 0px;
        display: inline;
    }
    .codearea {
        width: min-content;
        min-height: calc(100vh - 40px);
        min-width: calc(100vw - 100px);
        margin: 0px;
        padding: 20px;
        padding-left: 80px;
        border-radius: 10px;
        top: 10px;
        position: absolute;
        top: 0px;
        left: 0px;
        font-size: 15px;
        background: rgb(0,0,0,0);
        color: rgb(255, 255, 255);
        border: 0px;
        display: block;
        outline: none;
    }
    body {
        background-color: black;
    }

    #linearea {
        padding-left: 5px;
        width: 55px;
        margin: 0px;
        padding: 0px;
        padding-top: 20px;
        padding-bottom: 20px;
        padding-right: 10px;
        position: absolute;
        top: 0px;
        left: 0px;
        display: block;
        font-size: 15px;
        text-align: right;
        background: rgb(81, 84, 91);
        color: rgb(235, 235, 235);
    }
</style>